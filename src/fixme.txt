./Common/Observer.hpp:105:        // FIXME ugly patch to avoid segfault loop iterator + erase
./Common/Observer.hpp:119:  std::vector<Observer<T, A> *> observers_; // FIXME containers
./Common/Observer.hpp:94:    observers_.clear();//FIXME
./Common/ResourceManager.hpp:69:  //! FIXME: not safe against delete.
./Common/Resources.hpp:16:  virtual ~IResource() { };  // FIXME: private to avoid delete
./main.cpp:43:// FIXME: faire une classe avec une methode pure pour lancer les trucs de 'utilsateur
./OpenGL/Renderer.cpp:85:  // FIXME: a fusionner avec la camera
./OpenGL/Renderer.cpp:88:  // FIXME ajouter un flag pour eviter de faire des calculs
./OpenGL/Renderer.hpp:125:   * TODO: ajouter une texture comme fond d'ecran
./OpenGL/Renderer.hpp:64:  void applyViewport(Camera2D& camera) // FIXME: pas de const a cause de getTransform
./OpenGL/Renderer.hpp:68:    // FIXME
./OpenGL/Renderer.hpp:74:  inline void applyViewport() // FIXME const;
./OpenGL/Shader.cpp:176:  // FIXME: je ne suis pas trop sur de ce code
./OpenGL/Textures.hpp:37:  // TODO: tester 2 chargement textures a la suite avec/sans echec
./OpenGL/Textures.hpp:77:  // FIXME: useful ? Never used !
./SimForth/Forth/Forth.cpp:208:              // FIXME: changer le message
./SimForth/Forth/Forth.cpp:300:      // FIXME eviter de retester des mots deja vus en pasant en param
./SimForth/Forth/Forth.cpp:568:// FIXME: convert char* --> string can be consumns lot of memory ?!
./SimForth/Forth/Forth.cpp:600:      // FIXME: le stream peut ne pas etre termine: attendre
./SimForth/Forth/Forth.cpp:601:      // FIXME: retourne ok si on lui donne une ligne vide dans un string
./SimForth/Forth/Forth.cpp:607:      // TODO: checker les piles
./SimForth/Forth/Forth.cpp:608:      #warning "TODO check if stack depth changed during include!"
./SimForth/Forth/Forth.cpp:616:          // FIXME: the stream colum information is erroneous because
./SimForth/Forth/Forth.cpp:654:      abort(); // FIXME bad location
./SimForth/Forth/ForthDictionary.cpp:272:bool ForthDictionary::dump(std::string const& filename) // FIXME const
./SimForth/Forth/ForthDictionary.cpp:281:      // TODO: ajouter un param ou commence la sauvegarde dans le dico (ex: skip primitives)
./SimForth/Forth/ForthDictionary.cpp:555:                      // FIXME: ugly but how to fix that ?
./SimForth/Forth/ForthDictionary.cpp:655:  // FIXME: proteger en ecriture les anciens mots definis
./SimForth/Forth/ForthDictionary.cpp:656:  // FIXME: autoriser en lecture toutes les addr du dico
./SimForth/Forth/ForthDictionary.cpp:668:// FIXME: au lieu de addr >= &m_dictionary[maxPrimitives()]
./SimForth/Forth/ForthDictionary.cpp:737:  // FIXME Cell8 *const addr
./SimForth/Forth/ForthDictionary.hpp:102:  bool dump(std::string const& filename);// FIXME const;
./SimForth/Forth/ForthDictionary.hpp:181:  // FIXME std::string m_name;
./SimForth/Forth/ForthHelper.hpp:39:// FIXME: Maybe we can divide / 2 addresses because they are aligned.
./SimForth/Forth/ForthHelper.hpp:44:// FIXME: COMPIL_ASSERT_TIME((DICTIONARY_SIZE - 1U) <= CELL16_MAX_VALUE)
./SimForth/Forth/ForthPrimitives.cpp:352:      DPOP(m_tos1); // FIXME: optim: RPUSH(DPOP);
./SimForth/Forth/ForthPrimitives.cpp:661:  // TODO: Les ranger par ordre lexico ?
./SimForth/Forth/ForthPrimitives.cpp:662:  // FIXME: init m_last et m_here pour etre sur que le client ne
./SimForth/SimForth.cpp:53:  // FIXME: let try to get an ancestor
./SimForth/SimForth.cpp:54:  // FIXME: temporaire car on ne va pas que gerer la fonction cout
./SimForth/SimForth.cpp:97:      // FIXME: temporaire car on ne va pas que gerer la fonction cout
./SimGui/DrawingArea.cpp:81:      //FIXME: GLRenderer::release();
./SimGui/ForthEditor.cpp:129:// Slot. FIXME: gerer les commentaires
./SimGui/ForthEditor.cpp:135:  // FIXME: enlever les tags
./SimGui/ForthEditor.cpp:151:      // TODO: not in a comment
./SimGui/ForthEditor.cpp:153:        // Mark unknown word. FIXME underline IMMEDIATE words
./SimGui/ForthEditor.cpp:183:  // FIXME: reset completion state
./SimGui/ForthEditor.cpp:239:    m_submenu[2].signal_activate().connect(sigc::mem_fun(*this, &ForthEditor::empty));// TODO
./SimGui/ForthEditor.cpp:304:    // FIXME: mettre les text view en read-only
./SimGui/ForthEditor.cpp:332:    // TBD: ouvrir l'onglet concerne ?
./SimGui/ForthEditor.cpp:353:  // TODO: be sure no script is running on the map before destroying
./SimGui/ForthEditor.cpp:354:  // TODO: save the historic buffer
./SimGui/ForthEditor.cpp:419:      // FIXME return not taken into account
./SimGui/ForthEditor.cpp:455:      // FIXME return not taken into account
./SimGui/ForthEditor.cpp:537:      // TODO: inserer nouveau mot dans tree
./SimGui/ForthEditor.cpp:557:  // FIXME: ajouter le numero du bouton dans le nom pour eviter
./SimGui/ForthEditor.cpp:580:          m_statusbar.push("Use ignored saving the Forth script button"); // FIXME: inutile car ecrase par le resultat de l'exec
./SimGui/ForthEditor.cpp:591:  // FIXME: quand on sauvegarde ne pas stocker dans un fichier mais dans le bouton
./SimGui/ForthEditor.cpp:606:  // FIXME: quand on sauvegarde ne pas stocker dans un fichier mais dans le menu
./SimGui/ForthEditor.cpp:620:      // FIXME: Clear the text editor if and only if we are in an interactive mode
./SimGui/ForthEditor.cpp:630:      // TODO: select in red the faulty word
./SimGui/ForthEditor.cpp:636:// FIXME const Cell16 ForthToken)
./SimGui/ForthEditor.cpp:638:// FIXME: si pile vide ou pas le bon nombre d'elements alors fenetre popup qui demande les param
./SimGui/ForthEditor.cpp:639:// FIXME: ajouter le postip avec la definiton du mot "WORD ( n1 n2 -- n3 n4 )"
./SimGui/ForthEditor.cpp:640:// FIXME ne pas autoriser a compiler
./SimGui/ForthEditor.cpp:659:      //FIXME Gtk::MessageDialog dialog(*this, "Failed creating a Forth button");
./SimGui/ForthEditor.hpp:20:  // FIXME changer le nom de cette fonction
./SimGui/ForthEditor.hpp:56:  void execButton(Gtk::ToolButton* button); // FIXME nom
./SimGui/ForthEditor.hpp:68:                            const std::string &help);  // FIXME: Glib::ustring, const Cell16 Forthtoken);
./SimGui/ForthEditor.hpp:70:  Gtk::Notebook          m_res_notebooks[2]; // FIXME: attention collision de noms TextEditor::m_notebook
./SimGui/ForthEditor.hpp:83:  //SimForth* m_forth; // FIXME: utile si on gere plusieurs cartes
./SimGui/MapEditor.cpp:101:  // TODO: be sure no Forth script is running on the map before destroying mapq
./SimGui/MapEditor.cpp:184:      //FIXME if (bool) { selectionner toutes la map pour permettre a l'utilisateur de la placer la ou il vaut }
./SimGui/MapEditor.cpp:185:      //FIXME zoomer sur la fusion des deux bounding box de l'ancinne et nouvelle map }
./SimGui/MapEditor.hpp:44:    // TODO
./SimGui/MapEditor.hpp:48:    // TODO
./SimGui/Redirection.hpp:8:// TODO: set_color() ?
./SimGui/SimTaDynWindow.cpp:107:  // FIXME: do the same for MapEditor
./SimGui/SimTaDynWindow.cpp:45:  // * _Plugins: TBD: Let the user to add an menu calling it's on fprth scripts.
./SimGui/SimTaDynWindow.cpp:46:  // * _Help: TBD: add About/help/interactive tutorials
./SimGui/SimTaDynWindow.cpp:59:    // TODO: submenus Tuto, Help, Example, About
./SimGui/SimTaDynWindow.hpp:54:  std::vector<Gtk::ToolButton> m_toolbuttons; // FIXME resize
./SimGui/TextEditor.cpp:293:    m_button(""), // FIXME a passer en param
./SimGui/TextEditor.cpp:34:          // FIXME: display error
./SimGui/TextEditor.cpp:375:      // FIXME BUG si  m_filename == ""
./SimGui/TextEditor.cpp:42:      // FIXME: highligth the line
./SimGui/TextEditor.cpp:432:// of the file. Note: we do not popup a dialog to ask if needed saving (TBD: bool save_before_otrunc)
./SimGui/TextEditor.cpp:540:// FIXME:: le seul endroit ou appeller les sauvegardes
./SimGui/TextEditor.cpp:636:  // FIXME: faire apparaitre avant de tuer la fenetre principale sinon le dialog peut etre cache par d'autres fentres
./SimGui/TextEditor.cpp:769:          //std::cout << "'" << filename << "' already opened\n"; // TODO statusbar
./SimGui/TextEditor.cpp:814:      // TBD: compare title ou filename ou les deux ?
./SimGui/TextEditor.cpp:861:  // FIXME: mettre en gris le fond si le document est en read-only
./SimGui/TextEditor.cpp:874:      if (0 == doc->m_filename.compare("")) // FIXME || read-only(file)
./SimGui/TextEditor.hpp:160:// TBD: undo/redo
./SimGui/TextEditor.hpp:228:  // FIXME: mode interactif ==> ne pas sauvegarder
./SimMap/Graph/BasicGraph.hpp:399:        N* node = m_nodes.get(nodeID); // FIXME direct access c'est ok
./SimMap/Graph/CellForth.hpp:103:    // FIXME ne pas laisser faire un std::cout
./SimMap/Graph/CellForth.hpp:112:  static Forth *m_forth; // FIXME share_ptr
./SimMap/Graph/CellForth.hpp:84:    // FIXME verifier que la pile n'a pas change de profondeur
./SimMap/Graph/GraphMemory.hpp:165:        // TODO: exception instead of assert
./SimMap/Graph/GraphMemory.hpp:488:    uint32_t emptyPoolB() const // FIXME Chnager nom
./SimMap/Graph/GraphMemory.hpp:507:    uint32_t emptyPoolE() const // FIXME Chnager nom
./SimMap/Graph/GraphMemory.hpp:523:    // FIXME overloader operator[] pour acceder au slot sans passer par les securites de get()
./SimMap/Graph/GraphMemory.hpp:609:      //! \brief FIXME. Devrait utiliser l'heritage pour ajouter ce champs
./SimMap/Graph/SimTaDynGraph.hpp:32:  // FIXME: temporary
./SimMap/Graph/SimTaDynGraph.hpp:70:  // FIXME: temporary
./SimMap/Loaders/MapLoader.hpp:27:  // FIXME: faire onError()
./SimMap/Loaders/ShapeFile.cpp:262:  try // FIXME: comment faire undo en cas d'echec ?
./SimMap/old/oldCells/BasicGraph.hpp:158:  N* getNode(const Key nodeID) const // TODO shareptr
./SimMap/old/oldCells/BasicGraph.hpp:174:        N* node = *(m_nodes.get(nodeID)); // FIXME degeux
./SimMap/old/oldCells/BasicGraph.hpp:260:  // TBD: vector<Key> or vector<IArcs*>
./SimMap/old/oldCells/BasicGraph.hpp:266:        // FIXME throw exception
./SimMap/old/oldCells/BasicGraph.hpp:32:  // TBD: Key or shareptr<BasicNode> ?
./SimMap/old/oldCells/SimTaDynArcs.hpp:24:  // FIXME utiliser des &
./SimMap/old/oldCells/SimTaDynCells.hpp:121:  //std::vector<SimTaDynCell*> subjects_; // FIXME: trouver meilleur container
./SimMap/old/oldCells/SimTaDynCells.hpp:273:   * Accessor: set a value instead of the code forth result.  FIXME:
./SimMap/old/oldCells/SimTaDynGraphs.hpp:11:// FIXME: SimForth m_forth;
./SimMap/old/oldCells/SimTaDynGraphs.hpp:59:    SimTaDynCell* node = new SimTaDynCell();// FIXMEnew SimTaDynNode();
./SimMap/old/oldCells/SimTaDynGraphs.hpp:62:    node->moveToPosition(p);// FIXME pas optim
./SimMap/old/oldCells/SimTaDynGraphs.hpp:73:    SimTaDynCell* node = new SimTaDynCell(name, code_forth, data);// FIXMEnew SimTaDynNode();
./SimMap/old/oldCells/SimTaDynGraphs.hpp:7:// FIXME: changer nom ou alors SimTaDynMap = { SimTaDynGraph + RTree + Forth }
./SimMap/RTree/RTreeIndex.cpp:63:  if (IS_A_RTREE_LEAF(level)) // FIXME: faire if (is_leaf())
./SimMap/RTree/RTreeNode.cpp:8:  level = 0; // FIXME -1
./SimMap/SimTaDynMap.cpp:23:#warning "fixme 01"
./SimMap/SimTaDynMap.cpp:24:  SimTaDynNode *the_last = nullptr; // TODO m_graph.getLastNode();
./SimMap/SimTaDynMap.cpp:33:#warning "fixme 02"
./SimMap/SimTaDynMap.cpp:3:// FIXME: temporaire
./SimMap/SimTaDynMap.hpp:102:  // TODO liste de scripts Forth
./SimMap/SimTaDynMap.hpp:105:  //! \brief Spatial index FIXME: drawble rtree
./SimMap/SimTaDynMap.hpp:109:  //! FIXME: TEMPORAIRE car sera donner par Rtree.bbox()
./SimMap/SimTaDynMap.hpp:117:  //! \brief database FIXME TBD:
./SimMap/SimTaDynMap.hpp:12:// FIXME: faut creer une class helper pour charger une seule fois les
./SimMap/SimTaDynMap.hpp:49:    //FIXME MapEditor::instance().remove(id());
./SimMap/SimTaDynMap.hpp:78:    // FIXME: a faire par la suite m_spatial_index.root.bbox()
